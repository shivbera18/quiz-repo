import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const { prompt, operation, difficulty, count } = await request.json()

    // Try Gemini API first if API key is available
    if (process.env.GEMINI_API_KEY) {
      try {
        const questions = await generateWithGemini(prompt, operation, difficulty, count)
        return NextResponse.json({ questions })
      } catch (geminiError) {
        console.error('Gemini API failed, falling back to local generation:', geminiError)
      }
    }
    
    // Fallback to local generation
    const questions = generateLocalQuestions(operation, difficulty, count)
    
    return NextResponse.json({ questions })
  } catch (error) {
    console.error('Error generating flashcards:', error)
    return NextResponse.json(
      { error: 'Failed to generate flashcards' },
      { status: 500 }
    )
  }
}

// Gemini API integration
async function generateWithGemini(prompt: string, operation: string, difficulty: string, count: number) {
  const apiKey = process.env.GEMINI_API_KEY
  if (!apiKey) {
    throw new Error('Gemini API key not found')
  }

  const enhancedPrompt = `Generate ${count} ${operation.toLowerCase()} problems for ${difficulty} numbers. 
For each problem, provide 4 multiple choice options where exactly one is correct.
Return ONLY a JSON array in this exact format:
[
  {
    "question": "45 + 28",
    "answer": 73,
    "options": ["71", "73", "75", "77"],
    "correctOptionIndex": 1,
    "operation": "${operation}",
    "difficulty": "${difficulty}"
  }
]
Make sure the correct answer appears in the options array and correctOptionIndex points to it.
Keep numbers reasonable for mental math practice.`

  const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      contents: [{
        parts: [{
          text: enhancedPrompt
        }]
      }]
    })
  })

  if (!response.ok) {
    throw new Error(`Gemini API error: ${response.status}`)
  }

  const data = await response.json()
  const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text

  if (!generatedText) {
    throw new Error('No content generated by Gemini')
  }

  try {
    // Extract JSON from the response
    const jsonMatch = generatedText.match(/\[[\s\S]*\]/)
    if (!jsonMatch) {
      throw new Error('No JSON found in Gemini response')
    }

    const questions = JSON.parse(jsonMatch[0])
    
    // Validate and fix each question
    return questions.map((q: any, index: number) => ({
      id: `gemini-${operation}-${difficulty}-${index}`,
      question: q.question || `${Math.floor(Math.random() * 50) + 10} + ${Math.floor(Math.random() * 50) + 10}`,
      answer: q.answer || 0,
      options: Array.isArray(q.options) && q.options.length === 4 ? q.options : generateOptionsForAnswer(q.answer || 0, operation),
      correctOptionIndex: typeof q.correctOptionIndex === 'number' ? q.correctOptionIndex : (Array.isArray(q.options) ? q.options.findIndex((opt: string) => parseInt(opt) === q.answer) : 0),
      operation: q.operation || operation,
      difficulty: q.difficulty || difficulty
    }))

  } catch (parseError) {
    console.error('Failed to parse Gemini response:', parseError)
    throw new Error('Failed to parse Gemini response')
  }
}

// Helper function to generate options for a given answer
function generateOptionsForAnswer(answer: number, operation: string): string[] {
  const options: string[] = []
  const wrongAnswers = new Set<number>()
  
  // Generate 3 wrong answers
  let attempts = 0
  while (wrongAnswers.size < 3 && attempts < 50) {
    let wrongAnswer: number
    const variance = Math.floor(Math.random() * 21) - 10 // -10 to +10
    
    switch (operation) {
      case "Addition":
        wrongAnswer = answer + variance
        if (variance === 0) wrongAnswer = answer + (Math.random() > 0.5 ? 5 : -5)
        break
      case "Subtraction":
        wrongAnswer = answer + variance
        if (variance === 0) wrongAnswer = answer + (Math.random() > 0.5 ? 3 : -3)
        break
      case "Multiplication":
        const multVariance = Math.floor(Math.random() * 51) - 25
        wrongAnswer = answer + multVariance
        if (multVariance === 0) wrongAnswer = answer + (Math.random() > 0.5 ? 10 : -10)
        break
      case "Division":
        wrongAnswer = answer + Math.floor(Math.random() * 11) - 5
        if (wrongAnswer === answer) wrongAnswer = answer + (Math.random() > 0.5 ? 2 : -2)
        break
      default:
        wrongAnswer = answer + variance
        if (variance === 0) wrongAnswer = answer + (Math.random() > 0.5 ? 5 : -5)
    }
    
    if (wrongAnswer > 0 && wrongAnswer !== answer && !wrongAnswers.has(wrongAnswer)) {
      wrongAnswers.add(wrongAnswer)
    }
    attempts++
  }
  
  // Ensure we have 3 wrong answers
  while (wrongAnswers.size < 3) {
    const baseWrong = answer + (wrongAnswers.size + 1) * (Math.random() > 0.5 ? 1 : -1)
    if (baseWrong > 0 && baseWrong !== answer && !wrongAnswers.has(baseWrong)) {
      wrongAnswers.add(baseWrong)
    }
  }
  
  // Add wrong answers to options
  wrongAnswers.forEach(wa => options.push(wa.toString()))
  
  // Add correct answer
  options.push(answer.toString())
  
  // Shuffle options
  return options.sort(() => Math.random() - 0.5)
}

// Local question generation function (fallback)
function generateLocalQuestions(
  operation: string, 
  difficulty: "2-digit" | "3-digit" | "mixed", 
  count: number = 10
) {
  const questions = []
  
  for (let i = 0; i < count; i++) {
    const currentDifficulty = difficulty === "mixed" 
      ? Math.random() > 0.5 ? "2-digit" : "3-digit"
      : difficulty
    
    const range = currentDifficulty === "2-digit" ? [10, 99] : [100, 999]
    let question = ""
    let answer = 0
    
    switch (operation) {
      case "Addition": {
        const a = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0]
        const b = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0]
        answer = a + b
        question = `${a} + ${b}`
        break
      }
      case "Subtraction": {
        const a = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0]
        const b = Math.floor(Math.random() * a) + Math.floor(range[0] / 2) // Ensure positive result
        answer = a - b
        question = `${a} - ${b}`
        break
      }
      case "Multiplication": {
        const maxRange = currentDifficulty === "2-digit" ? [2, 25] : [2, 50]
        const a = Math.floor(Math.random() * (maxRange[1] - maxRange[0] + 1)) + maxRange[0]
        const b = Math.floor(Math.random() * (maxRange[1] - maxRange[0] + 1)) + maxRange[0]
        answer = a * b
        question = `${a} ร ${b}`
        break
      }
      case "Division": {
        const divisor = Math.floor(Math.random() * 20) + 2
        const quotient = currentDifficulty === "2-digit" 
          ? Math.floor(Math.random() * 50) + 2
          : Math.floor(Math.random() * 200) + 2
        const dividend = divisor * quotient
        answer = quotient
        question = `${dividend} รท ${divisor}`
        break
      }
    }
    
    // Generate options using the helper function
    const options = generateOptionsForAnswer(answer, operation)
    const correctOptionIndex = options.findIndex(option => parseInt(option) === answer)
    
    questions.push({
      id: `local-${operation}-${currentDifficulty}-${i}`,
      question,
      answer,
      options,
      correctOptionIndex,
      operation,
      difficulty: currentDifficulty
    })
  }
  
  return questions
}
